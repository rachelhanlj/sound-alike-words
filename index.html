<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è¿‘éŸ³è¯æœç´¢ - Phonetic Word Finder</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            padding: 40px 30px;
            text-align: center;
            color: white;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .search-section {
            padding: 40px 30px;
            background: #f8f9ff;
        }

        .search-container {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .search-input {
            flex: 1;
            min-width: 200px;
            padding: 15px 20px;
            border: 2px solid #e0e7ff;
            border-radius: 15px;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        .search-input:focus {
            outline: none;
            border-color: #4facfe;
            box-shadow: 0 0 20px rgba(79, 172, 254, 0.2);
        }

        .search-btn {
            padding: 15px 30px;
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            border: none;
            border-radius: 15px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 120px;
        }

        .search-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(79, 172, 254, 0.4);
        }

        .search-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .result-section {
            padding: 0 30px 40px;
        }

        .phonetic-info {
            background: #fff;
            border: 2px solid #e0e7ff;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            display: none;
        }

        .phonetic-info h3 {
            color: #333;
            margin-bottom: 20px;
            font-size: 1.3em;
        }

        .phonetic-transcription {
            background: #f0f4ff;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .phonetic-transcription li {
            list-style: none;
            margin-bottom: 10px;
            font-size: 16px;
        }

        .bold {
            font-weight: bold;
            color: #4facfe;
        }

        .syllables {
            background: #fff;
            padding: 15px;
            border-radius: 8px;
            margin-top: 10px;
            border-left: 4px solid #4facfe;
        }

        .word-translation {
            background: #e8f4fd;
            padding: 15px;
            border-radius: 8px;
            margin-top: 10px;
            border-left: 4px solid #4facfe;
        }

        .word-translation .word-text {
            font-size: 18px;
            font-weight: bold;
            color: #333;
            margin-bottom: 5px;
        }

        .word-translation .translation-text {
            font-size: 16px;
            color: #666;
        }

        .similar-words {
            display: none;
        }

        .similar-words h4 {
            color: #333;
            margin-bottom: 20px;
            font-size: 1.2em;
        }

        .word-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
        }

        .word-item {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 18px;
            border-radius: 15px;
            text-decoration: none;
            transition: all 0.3s ease;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }

        .word-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
            text-decoration: none;
            color: white;
        }

        .word-item .word-english {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 5px;
        }

        .word-item .word-chinese {
            font-size: 14px;
            opacity: 0.9;
            font-weight: 400;
        }

        .loading {
            text-align: center;
            padding: 40px;
            display: none;
        }

        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #4facfe;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error-message {
            background: #fee;
            color: #c33;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: none;
            border-left: 4px solid #c33;
        }

        .example-searches {
            background: #f0f4ff;
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
        }

        .example-searches h4 {
            margin-bottom: 15px;
            color: #333;
        }

        .example-tags {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .example-tag {
            background: white;
            color: #4facfe;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid #4facfe;
        }

        .example-tag:hover {
            background: #4facfe;
            color: white;
        }

        @media (max-width: 768px) {
            .search-container {
                flex-direction: column;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .word-grid {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ” è¿‘éŸ³è¯æœç´¢</h1>
            <p>Phonetic Word Finder - å‘ç°å‘éŸ³ç›¸ä¼¼çš„è‹±è¯­å•è¯ï¼ˆå¸¦ä¸­æ–‡ç¿»è¯‘ï¼‰</p>
        </div>

        <div class="search-section">
            <div class="example-searches">
                <h4>ğŸš€ è¯•è¯•è¿™äº›ç¤ºä¾‹ï¼š</h4>
                <div class="example-tags">
                    <span class="example-tag" onclick="searchExample('cognitive')">cognitive</span>
                    <span class="example-tag" onclick="searchExample('conductive')">conductive</span>
                    <span class="example-tag" onclick="searchExample('productive')">productive</span>
                    <span class="example-tag" onclick="searchExample('creative')">creative</span>
                    <span class="example-tag" onclick="searchExample('support')">support</span>
                </div>
            </div>

            <div class="search-container">
                <input type="text" class="search-input" id="searchInput" placeholder="è¾“å…¥è‹±è¯­å•è¯..." />
                <button class="search-btn" onclick="searchSimilarWords()">æœç´¢è¿‘éŸ³è¯</button>
            </div>

            <div class="error-message" id="errorMessage"></div>
        </div>

        <div class="result-section">
            <div class="loading" id="loading">
                <div class="loading-spinner"></div>
                <p>æ­£åœ¨æœç´¢è¿‘éŸ³è¯å’Œç¿»è¯‘...</p>
            </div>

            <div class="phonetic-info" id="phoneticInfo">
                <h3>ğŸ“ éŸ³æ ‡ä¿¡æ¯</h3>
                <ul class="phonetic-transcription" id="phoneticTranscription">
                </ul>
                <div class="word-translation" id="wordTranslation"></div>
            </div>

            <div class="similar-words" id="similarWords">
                <h4>ğŸ¯ å‘éŸ³ç›¸ä¼¼çš„å•è¯ï¼š</h4>
                <div class="word-grid" id="wordGrid"></div>
            </div>
        </div>
    </div>

    <script>
        // é¢„å®šä¹‰çš„éŸ³æ ‡å’Œç¿»è¯‘æ•°æ®åº“ï¼ˆæ‰©å±•ç‰ˆï¼‰
        const phoneticDatabase = {
            'cognitive': {
                modern: 'ËˆkÉ’É¡nÉªtÉªv',
                traditional: 'ËˆkÉ’É¡nÉªtÉªv',
                syllables: ['COG', 'ni', 'tive'],
                translation: 'è®¤çŸ¥çš„ï¼Œæ„ŸçŸ¥çš„',
                similar: ['connective', 'collective', 'corrective', 'protective', 'selective', 'detective', 'objective', 'subjective', 'effective', 'directive']
            },
            'conductive': {
                modern: 'kÉ™nËˆdÊŒktÉªv',
                traditional: 'kÉ™nËˆdÊŒktÉªv',
                syllables: ['con', 'DUC', 'tive'],
                translation: 'ä¼ å¯¼çš„ï¼Œå¯¼ç”µçš„',
                similar: ['productive', 'destructive', 'constructive', 'instructive', 'reductive', 'inductive', 'deductive', 'seductive', 'reproductive', 'counterproductive']
            },
            'productive': {
                modern: 'prÉ™ËˆdÊŒktÉªv',
                traditional: 'prÉ™ËˆdÊŒktÉªv',
                syllables: ['pro', 'DUC', 'tive'],
                translation: 'ç”Ÿäº§çš„ï¼Œå¯Œæœ‰æˆæ•ˆçš„',
                similar: ['conductive', 'destructive', 'constructive', 'instructive', 'reductive', 'reproductive', 'counterproductive', 'unproductive']
            },
            'creative': {
                modern: 'kriËˆeÉªtÉªv',
                traditional: 'kriËˆeÉªtÉªv',
                syllables: ['cre', 'A', 'tive'],
                translation: 'åˆ›é€ æ€§çš„ï¼Œæœ‰åˆ›æ„çš„',
                similar: ['innovative', 'initiative', 'decorative', 'comparative', 'narrative', 'operative', 'cooperative', 'collaborative', 'administrative', 'representative']
            },
            'effective': {
                modern: 'ÉªËˆfektÉªv',
                traditional: 'ÉªËˆfektÉªv',
                syllables: ['ef', 'FEC', 'tive'],
                translation: 'æœ‰æ•ˆçš„ï¼Œæœ‰æ•ˆæœçš„',
                similar: ['selective', 'collective', 'protective', 'objective', 'subjective', 'detective', 'corrective', 'directive', 'reflective', 'perspective']
            },
            'organization': {
                modern: 'ËŒÉ”ËÉ¡É™naÉªËˆzeÉªÊƒÉ™n',
                traditional: 'ËŒÉ”ËÉ¡É™naÉªËˆzeÉªÊƒÉ™n',
                syllables: ['OR', 'ga', 'ni', 'ZA', 'tion'],
                translation: 'ç»„ç»‡ï¼Œæœºæ„',
                similar: ['organisation', 'organizations', 'organisations', 'organizational', 'reorganization', 'americanization', 'disorganization', 'ionization', 'organism', 'organizer', 'organizing', 'modernization', 'standardization', 'characterization', 'crystallization']
            },
            'support': {
                modern: 'sÉ™ËˆpÉ”Ët',
                traditional: 'sÉ™ËˆpÉ”Ët',
                syllables: ['suh', 'PORT'],
                translation: 'æ”¯æŒï¼Œæ”¯æ’‘',
                similar: ['report', 'import', 'export', 'transport', 'deport', 'comfort', 'effort', 'sport', 'court', 'fort', 'sort', 'short', 'abort', 'distort', 'resort', 'consort', 'escort', 'supports', 'supporting', 'supported', 'supportive']
            }
        };

        // é¢„å®šä¹‰ç¿»è¯‘æ•°æ®åº“
        const translationDatabase = {
            // åŸºç¡€å•è¯
            'support': 'æ”¯æŒï¼Œæ”¯æ’‘',
            'report': 'æŠ¥å‘Šï¼Œæ±‡æŠ¥',
            'import': 'è¿›å£ï¼Œå¯¼å…¥',
            'export': 'å‡ºå£ï¼Œå¯¼å‡º',
            'transport': 'è¿è¾“ï¼Œäº¤é€š',
            'deport': 'é©±é€å‡ºå¢ƒ',
            'comfort': 'èˆ’é€‚ï¼Œå®‰æ…°',
            'effort': 'åŠªåŠ›ï¼Œå°è¯•',
            'sport': 'è¿åŠ¨ï¼Œä½“è‚²',
            'court': 'æ³•é™¢ï¼Œçƒåœº',
            'fort': 'å ¡å’ï¼Œè¦å¡',
            'sort': 'ç§ç±»ï¼Œåˆ†ç±»',
            'short': 'çŸ­çš„ï¼Œç¼ºå°‘',
            'abort': 'ä¸­æ­¢ï¼Œæµäº§',
            'distort': 'æ‰­æ›²ï¼Œæ­ªæ›²',
            'resort': 'åº¦å‡æ‘ï¼Œæ±‚åŠ©',
            'consort': 'é…å¶ï¼Œä¼™ä¼´',
            'escort': 'æŠ¤é€ï¼Œé™ªåŒ',
            
            // -ive ç»“å°¾
            'cognitive': 'è®¤çŸ¥çš„ï¼Œæ„ŸçŸ¥çš„',
            'conductive': 'ä¼ å¯¼çš„ï¼Œå¯¼ç”µçš„',
            'productive': 'ç”Ÿäº§çš„ï¼Œå¯Œæœ‰æˆæ•ˆçš„',
            'creative': 'åˆ›é€ æ€§çš„ï¼Œæœ‰åˆ›æ„çš„',
            'effective': 'æœ‰æ•ˆçš„ï¼Œæœ‰æ•ˆæœçš„',
            'selective': 'é€‰æ‹©æ€§çš„ï¼ŒæŒ‘å‰”çš„',
            'collective': 'é›†ä½“çš„ï¼Œå…±åŒçš„',
            'protective': 'ä¿æŠ¤æ€§çš„ï¼Œé˜²æŠ¤çš„',
            'objective': 'å®¢è§‚çš„ï¼Œç›®æ ‡',
            'subjective': 'ä¸»è§‚çš„ï¼Œä¸ªäººçš„',
            'detective': 'ä¾¦æ¢ï¼Œæ¢æµ‹çš„',
            'corrective': 'çº æ­£çš„ï¼Œæ”¹æ­£çš„',
            'directive': 'æŒ‡ä»¤ï¼ŒæŒ‡å¯¼çš„',
            'reflective': 'åå°„çš„ï¼Œæ·±æ€çš„',
            'perspective': 'è§‚ç‚¹ï¼Œé€è§†',
            'destructive': 'ç ´åæ€§çš„ï¼Œæ¯ç­çš„',
            'constructive': 'å»ºè®¾æ€§çš„ï¼Œç§¯æçš„',
            'instructive': 'æœ‰æ•™è‚²æ„ä¹‰çš„ï¼Œæœ‰å¯å‘çš„',
            'reductive': 'ç®€åŒ–çš„ï¼Œè¿˜åŸçš„',
            'inductive': 'å½’çº³çš„ï¼Œæ„Ÿåº”çš„',
            'deductive': 'æ¼”ç»çš„ï¼Œæ¨è®ºçš„',
            'seductive': 'è¯±äººçš„ï¼Œæœ‰é­…åŠ›çš„',
            'reproductive': 'ç”Ÿæ®–çš„ï¼Œå¤åˆ¶çš„',
            'counterproductive': 'é€‚å¾—å…¶åçš„ï¼Œåæ•ˆæœçš„',
            'unproductive': 'æ— ç”Ÿäº§åŠ›çš„ï¼Œå¾’åŠ³çš„',
            'innovative': 'åˆ›æ–°çš„ï¼Œé©æ–°çš„',
            'initiative': 'ä¸»åŠ¨æ€§ï¼Œå€¡è®®',
            'decorative': 'è£…é¥°æ€§çš„ï¼Œè£…é¥°ç”¨çš„',
            'comparative': 'æ¯”è¾ƒçš„ï¼Œç›¸å¯¹çš„',
            'narrative': 'å™è¿°çš„ï¼Œæ•…äº‹',
            'operative': 'æ“ä½œçš„ï¼Œç”Ÿæ•ˆçš„',
            'cooperative': 'åˆä½œçš„ï¼Œåä½œçš„',
            'collaborative': 'åä½œçš„ï¼Œåˆä½œçš„',
            'administrative': 'è¡Œæ”¿çš„ï¼Œç®¡ç†çš„',
            'representative': 'ä»£è¡¨æ€§çš„ï¼Œä»£è¡¨',
            'active': 'ç§¯æçš„ï¼Œæ´»è·ƒçš„',
            'passive': 'è¢«åŠ¨çš„ï¼Œæ¶ˆæçš„',
            'massive': 'å·¨å¤§çš„ï¼Œå¤§é‡çš„',
            'native': 'æœ¬åœ°çš„ï¼Œå¤©ç”Ÿçš„',
            'alternative': 'æ›¿ä»£çš„ï¼Œé€‰æ‹©',
            'relative': 'ç›¸å¯¹çš„ï¼Œäº²æˆš',
            'negative': 'æ¶ˆæçš„ï¼Œè´Ÿé¢çš„',
            'positive': 'ç§¯æçš„ï¼Œæ­£é¢çš„',
            'sensitive': 'æ•æ„Ÿçš„ï¼Œçµæ•çš„',
            'expensive': 'æ˜‚è´µçš„ï¼ŒèŠ±è´¹å¤§çš„',
            'extensive': 'å¹¿æ³›çš„ï¼Œå¤§é‡çš„',
            'intensive': 'å¯†é›†çš„ï¼Œå¼ºçƒˆçš„',
            'comprehensive': 'å…¨é¢çš„ï¼Œç»¼åˆçš„',
            'progressive': 'è¿›æ­¥çš„ï¼Œæ¸è¿›çš„',
            'aggressive': 'æ”»å‡»æ€§çš„ï¼Œç§¯æçš„',
            'impressive': 'ä»¤äººå°è±¡æ·±åˆ»çš„',
            'competitive': 'ç«äº‰çš„ï¼Œæœ‰ç«äº‰åŠ›çš„',
            
            // -ation ç»“å°¾
            'organization': 'ç»„ç»‡ï¼Œæœºæ„',
            'organisation': 'ç»„ç»‡ï¼Œæœºæ„',
            'nation': 'å›½å®¶ï¼Œæ°‘æ—',
            'station': 'è½¦ç«™ï¼Œç”µå°',
            'creation': 'åˆ›é€ ï¼Œåˆ›ä½œ',
            'education': 'æ•™è‚²ï¼ŒåŸ¹å…»',
            'information': 'ä¿¡æ¯ï¼Œèµ„æ–™',
            'formation': 'å½¢æˆï¼Œæ„æˆ',
            'operation': 'æ“ä½œï¼Œè¿ä½œ',
            'population': 'äººå£ï¼Œç¾¤ä½“',
            'preparation': 'å‡†å¤‡ï¼Œé¢„å¤‡',
            'presentation': 'æ¼”ç¤ºï¼Œå±•ç¤º',
            'communication': 'äº¤æµï¼Œé€šä¿¡',
            'transportation': 'è¿è¾“ï¼Œäº¤é€š',
            'investigation': 'è°ƒæŸ¥ï¼Œç ”ç©¶',
            'administration': 'ç®¡ç†ï¼Œè¡Œæ”¿',
            'registration': 'æ³¨å†Œï¼Œç™»è®°',
            'demonstration': 'æ¼”ç¤ºï¼Œç¤ºèŒƒ',
            'recommendation': 'æ¨èï¼Œå»ºè®®',
            'concentration': 'ä¸“æ³¨ï¼Œæµ“åº¦',
            'celebration': 'åº†ç¥ï¼Œåº†å…¸',
            'vacation': 'å‡æœŸï¼Œåº¦å‡',
            'relation': 'å…³ç³»ï¼Œè”ç³»',
            'situation': 'æƒ…å†µï¼Œå½¢åŠ¿',
            'location': 'ä½ç½®ï¼Œåœ°ç‚¹',
            'invitation': 'é‚€è¯·ï¼Œè¯·æŸ¬',
            'motivation': 'åŠ¨æœºï¼ŒåŠ¨åŠ›',
            'inspiration': 'çµæ„Ÿï¼Œå¯å‘',
            'americanization': 'ç¾å›½åŒ–',
            'modernization': 'ç°ä»£åŒ–',
            'standardization': 'æ ‡å‡†åŒ–',
            'characterization': 'ç‰¹å¾æè¿°',
            'crystallization': 'ç»“æ™¶åŒ–',
            'ionization': 'ç¦»å­åŒ–',
            'civilization': 'æ–‡æ˜ï¼Œæ–‡åŒ–',
            'realization': 'å®ç°ï¼Œè®¤è¯†',
            'localization': 'æœ¬åœ°åŒ–',
            'optimization': 'ä¼˜åŒ–',
            'maximization': 'æœ€å¤§åŒ–',
            'minimization': 'æœ€å°åŒ–',
            'specialization': 'ä¸“ä¸šåŒ–',
            'globalization': 'å…¨çƒåŒ–',
            'privatization': 'ç§æœ‰åŒ–',
            'digitization': 'æ•°å­—åŒ–',
            'urbanization': 'åŸå¸‚åŒ–',
            'democratization': 'æ°‘ä¸»åŒ–',
            'decentralization': 'åˆ†æ•£åŒ–',
            'reorganization': 'é‡ç»„ï¼Œæ”¹ç»„',
            'disorganization': 'æ··ä¹±ï¼Œæ— ç»„ç»‡',
            
            // -tion ç»“å°¾
            'action': 'è¡ŒåŠ¨ï¼ŒåŠ¨ä½œ',
            'section': 'éƒ¨åˆ†ï¼ŒåŒºåŸŸ',
            'function': 'åŠŸèƒ½ï¼Œä½œç”¨',
            'production': 'ç”Ÿäº§ï¼Œåˆ¶ä½œ',
            'protection': 'ä¿æŠ¤ï¼Œé˜²æŠ¤',
            'construction': 'å»ºè®¾ï¼Œæ„é€ ',
            'destruction': 'ç ´åï¼Œæ¯ç­',
            'instruction': 'æŒ‡ä»¤ï¼Œæ•™å­¦',
            'attraction': 'å¸å¼•ï¼Œæ™¯ç‚¹',
            'reaction': 'ååº”ï¼Œå›åº”',
            'interaction': 'äº’åŠ¨ï¼Œç›¸äº’ä½œç”¨',
            'transaction': 'äº¤æ˜“ï¼Œäº‹åŠ¡',
            'fraction': 'åˆ†æ•°ï¼Œéƒ¨åˆ†',
            'fiction': 'å°è¯´ï¼Œè™šæ„',
            'distinction': 'åŒºåˆ«ï¼Œå·®å¼‚',
            'extinction': 'ç­ç»ï¼Œæ¶ˆå¤±',
            'prediction': 'é¢„æµ‹ï¼Œé¢„è¨€',
            'addiction': 'ä¸Šç˜¾ï¼Œæ²‰æºº',
            
            // å…¶ä»–å¸¸è§è¯æ±‡
            'important': 'é‡è¦çš„ï¼Œé‡å¤§çš„',
            'different': 'ä¸åŒçš„ï¼Œå„å¼‚çš„',
            'available': 'å¯ç”¨çš„ï¼Œå¯å¾—åˆ°çš„',
            'possible': 'å¯èƒ½çš„ï¼Œå¯è¡Œçš„',
            'necessary': 'å¿…è¦çš„ï¼Œå¿…éœ€çš„',
            'interesting': 'æœ‰è¶£çš„ï¼Œæœ‰æ„æ€çš„',
            'difficult': 'å›°éš¾çš„ï¼Œè‰°éš¾çš„',
            'beautiful': 'ç¾ä¸½çš„ï¼Œæ¼‚äº®çš„',
            'wonderful': 'ç²¾å½©çš„ï¼Œæå¥½çš„',
            'successful': 'æˆåŠŸçš„ï¼Œæœ‰æˆå°±çš„',
            'powerful': 'å¼ºå¤§çš„ï¼Œæœ‰åŠ›çš„',
            'peaceful': 'å’Œå¹³çš„ï¼Œå®é™çš„',
            'careful': 'å°å¿ƒçš„ï¼Œè°¨æ…çš„',
            'helpful': 'æœ‰å¸®åŠ©çš„ï¼Œæœ‰ç”¨çš„',
            'useful': 'æœ‰ç”¨çš„ï¼Œå®ç”¨çš„',
            'harmful': 'æœ‰å®³çš„ï¼Œä¼¤å®³çš„',
            'painful': 'ç—›è‹¦çš„ï¼Œç–¼ç—›çš„',
            'grateful': 'æ„Ÿæ¿€çš„ï¼Œæ„Ÿè°¢çš„',
            'faithful': 'å¿ è¯šçš„ï¼Œå¿ å®çš„',
            'doubtful': 'æ€€ç–‘çš„ï¼Œä¸ç¡®å®šçš„',
            'hopeful': 'æœ‰å¸Œæœ›çš„ï¼Œä¹è§‚çš„',
            'cheerful': 'å¿«ä¹çš„ï¼Œæ„‰å¿«çš„',
            'respectful': 'å°Šæ•¬çš„ï¼Œæ­æ•¬çš„',
            'forgetful': 'å¥å¿˜çš„ï¼Œå¿˜è®°çš„',
            'delightful': 'ä»¤äººæ„‰å¿«çš„ï¼Œå¯çˆ±çš„',
            
            // åŠ¨è¯å½¢å¼
            'started': 'å¼€å§‹äº†ï¼Œå¯åŠ¨äº†',
            'finished': 'å®Œæˆäº†ï¼Œç»“æŸäº†',
            'worked': 'å·¥ä½œäº†ï¼Œèµ·ä½œç”¨äº†',
            'played': 'ç©äº†ï¼Œæ¼”å¥äº†',
            'studied': 'å­¦ä¹ äº†ï¼Œç ”ç©¶äº†',
            'visited': 'æ‹œè®¿äº†ï¼Œå‚è§‚äº†',
            'decided': 'å†³å®šäº†ï¼Œä¸‹å†³å¿ƒäº†',
            'provided': 'æä¾›äº†ï¼Œä¾›åº”äº†',
            'included': 'åŒ…æ‹¬äº†ï¼ŒåŒ…å«äº†',
            'considered': 'è€ƒè™‘äº†ï¼Œè®¤ä¸ºäº†',
            'developed': 'å‘å±•äº†ï¼Œå¼€å‘äº†',
            'happened': 'å‘ç”Ÿäº†ï¼Œç¢°å·§äº†',
            'changed': 'æ”¹å˜äº†ï¼Œå˜åŒ–äº†',
            'starting': 'å¼€å§‹ï¼Œå¯åŠ¨',
            'finishing': 'å®Œæˆï¼Œç»“æŸ',
            'working': 'å·¥ä½œï¼Œè¿ä½œ',
            'playing': 'ç©ï¼Œæ¼”å¥',
            'studying': 'å­¦ä¹ ï¼Œç ”ç©¶',
            'visiting': 'æ‹œè®¿ï¼Œå‚è§‚',
            'deciding': 'å†³å®šï¼Œå†³ç­–',
            'providing': 'æä¾›ï¼Œä¾›åº”',
            'including': 'åŒ…æ‹¬ï¼ŒåŒ…å«',
            'considering': 'è€ƒè™‘ï¼Œè®¤ä¸º',
            'developing': 'å‘å±•ï¼Œå¼€å‘',
            'happening': 'å‘ç”Ÿï¼Œè¿›è¡Œ',
            
            // æŠ€æœ¯å’Œå•†ä¸šè¯æ±‡
            'computer': 'è®¡ç®—æœºï¼Œç”µè„‘',
            'internet': 'äº’è”ç½‘ï¼Œç½‘ç»œ',
            'website': 'ç½‘ç«™ï¼Œç½‘å€',
            'software': 'è½¯ä»¶ï¼Œç¨‹åº',
            'hardware': 'ç¡¬ä»¶ï¼Œè®¾å¤‡',
            'database': 'æ•°æ®åº“',
            'network': 'ç½‘ç»œï¼Œç½‘ç»œç³»ç»Ÿ',
            'system': 'ç³»ç»Ÿï¼Œä½“ç³»',
            'program': 'ç¨‹åºï¼Œé¡¹ç›®',
            'project': 'é¡¹ç›®ï¼Œå·¥ç¨‹',
            'product': 'äº§å“ï¼Œåˆ¶å“',
            'service': 'æœåŠ¡ï¼Œç»´ä¿®',
            'business': 'å•†ä¸šï¼Œç”Ÿæ„',
            'company': 'å…¬å¸ï¼Œä¼ä¸š',
            'industry': 'å·¥ä¸šï¼Œè¡Œä¸š',
            'technology': 'æŠ€æœ¯ï¼Œç§‘æŠ€',
            'science': 'ç§‘å­¦ï¼Œå­¦ç§‘',
            'research': 'ç ”ç©¶ï¼Œè°ƒæŸ¥',
            'development': 'å‘å±•ï¼Œå¼€å‘',
            'management': 'ç®¡ç†ï¼Œç»è¥',
            'marketing': 'è¥é”€ï¼Œå¸‚åœº',
            'advertising': 'å¹¿å‘Šï¼Œå®£ä¼ ',
            'customer': 'å®¢æˆ·ï¼Œé¡¾å®¢',
            'market': 'å¸‚åœºï¼Œé›†å¸‚',
            'economy': 'ç»æµï¼ŒèŠ‚çº¦',
            
            // å˜å½¢è¯
            'supports': 'æ”¯æŒï¼Œæ”¯æ’‘ï¼ˆå¤æ•°/åŠ¨è¯ï¼‰',
            'supporting': 'æ”¯æŒçš„ï¼Œè¾…åŠ©çš„',
            'supported': 'è¢«æ”¯æŒçš„ï¼Œå—æ”¯æŒçš„',
            'supportive': 'æ”¯æŒæ€§çš„ï¼Œé¼“åŠ±çš„',
            'unsupported': 'ä¸è¢«æ”¯æŒçš„ï¼Œæ— æ ¹æ®çš„',
            'reports': 'æŠ¥å‘Šï¼ˆå¤æ•°/åŠ¨è¯ï¼‰',
            'reporting': 'æŠ¥å‘Šï¼Œæ±‡æŠ¥',
            'reported': 'è¢«æŠ¥å‘Šçš„ï¼Œæ®æŠ¥é“çš„',
            'reporter': 'è®°è€…ï¼ŒæŠ¥å‘Šè€…',
            'imports': 'è¿›å£ï¼ˆå¤æ•°/åŠ¨è¯ï¼‰',
            'exports': 'å‡ºå£ï¼ˆå¤æ•°/åŠ¨è¯ï¼‰',
            'transports': 'è¿è¾“ï¼ˆå¤æ•°/åŠ¨è¯ï¼‰',
            'sports': 'è¿åŠ¨ï¼ˆå¤æ•°ï¼‰',
            'ports': 'æ¸¯å£ï¼ˆå¤æ•°ï¼‰',
            'courts': 'æ³•é™¢ï¼Œçƒåœºï¼ˆå¤æ•°ï¼‰',
            'forts': 'å ¡å’ï¼ˆå¤æ•°ï¼‰',
            'sorts': 'ç§ç±»ï¼ˆå¤æ•°/åŠ¨è¯ï¼‰',
            'organizations': 'ç»„ç»‡ï¼ˆå¤æ•°ï¼‰',
            'organisations': 'ç»„ç»‡ï¼ˆå¤æ•°ï¼‰',
            'organizational': 'ç»„ç»‡çš„ï¼Œæœºæ„çš„',
            'organism': 'æœ‰æœºä½“ï¼Œç”Ÿç‰©',
            'organizer': 'ç»„ç»‡è€…ï¼Œæ•´ç†å™¨',
            'organizing': 'ç»„ç»‡ï¼Œæ•´ç†',
            'organized': 'æœ‰ç»„ç»‡çš„ï¼Œæ•´é½çš„',
            'organic': 'æœ‰æœºçš„ï¼Œè‡ªç„¶çš„',
            'organically': 'æœ‰æœºåœ°ï¼Œè‡ªç„¶åœ°',
            
            // æ–°å¢è¯æ±‡
            'connective': 'è¿æ¥çš„ï¼Œè¿æ¥è¯',
            'innovative': 'åˆ›æ–°çš„ï¼Œé©æ–°çš„',
            'productive': 'ç”Ÿäº§çš„ï¼Œå¯Œæœ‰æˆæ•ˆçš„',
            'destructive': 'ç ´åæ€§çš„ï¼Œæ¯ç­çš„',
            'constructive': 'å»ºè®¾æ€§çš„ï¼Œç§¯æçš„',
            'instructive': 'æœ‰æ•™è‚²æ„ä¹‰çš„ï¼Œæœ‰å¯å‘çš„',
            'reproductive': 'ç”Ÿæ®–çš„ï¼Œå¤åˆ¶çš„'
        };

        // æ‰©å±•çš„è¯æ±‡åº“ç”¨äºåŒ¹é…
        const extendedVocabulary = [
            // support ç›¸å…³
            'support', 'supports', 'supporting', 'supported', 'supportive', 'unsupported',
            'report', 'reports', 'reporting', 'reported', 'reporter', 'import', 'imports',
            'export', 'exports', 'transport', 'transports', 'deport', 'comfort', 'effort',
            'sport', 'sports', 'port', 'ports', 'court', 'courts', 'fort', 'forts',
            'sort', 'sorts', 'short', 'abort', 'distort', 'resort', 'consort', 'escort',
            
            // organization ç›¸å…³
            'organization', 'organisation', 'organizations', 'organisations', 
            'organizational', 'reorganization', 'disorganization', 'organism',
            'organizer', 'organizing', 'organized', 'organic', 'organically',
            
            // -ation ç»“å°¾çš„è¯
            'nation', 'station', 'creation', 'education', 'information', 'formation', 
            'operation', 'population', 'preparation', 'presentation', 'communication', 
            'transportation', 'investigation', 'administration', 'registration', 
            'demonstration', 'recommendation', 'concentration', 'celebration', 'vacation',
            'relation', 'situation', 'location', 'invitation', 'motivation', 'inspiration',
            'americanization', 'modernization', 'standardization', 'characterization',
            'crystallization', 'ionization', 'civilization', 'realization', 'localization',
            'optimization', 'maximization', 'minimization', 'specialization', 'globalization',
            'privatization', 'digitization', 'urbanization', 'democratization', 'decentralization',
            
            // -tion ç»“å°¾çš„è¯
            'action', 'section', 'function', 'production', 'protection', 'construction',
            'destruction', 'instruction', 'attraction', 'reaction', 'interaction', 'transaction',
            'fraction', 'fiction', 'distinction', 'extinction', 'prediction', 'addiction',
            
            // -ive ç»“å°¾çš„è¯
            'active', 'passive', 'massive', 'native', 'creative', 'innovative', 'productive', 
            'effective', 'selective', 'collective', 'protective', 'objective', 'subjective', 
            'detective', 'corrective', 'directive', 'reflective', 'perspective', 'constructive',
            'destructive', 'instructive', 'conductive', 'reproductive', 'competitive',
            'alternative', 'relative', 'negative', 'positive', 'sensitive', 'expensive',
            'extensive', 'intensive', 'comprehensive', 'progressive', 'aggressive', 'impressive',
            'cognitive', 'decorative', 'comparative', 'narrative', 'operative', 'cooperative', 
            'collaborative', 'administrative', 'representative',
            
            // å¸¸è§å•è¯
            'important', 'different', 'available', 'possible', 'necessary', 'interesting',
            'difficult', 'beautiful', 'wonderful', 'successful', 'powerful', 'peaceful',
            'careful', 'helpful', 'useful', 'harmful', 'painful', 'grateful', 'faithful',
            'doubtful', 'hopeful', 'cheerful', 'respectful', 'forgetful', 'delightful',
            
            // åŠ¨è¯è¿‡å»å¼å’Œç°åœ¨åˆ†è¯
            'started', 'finished', 'worked', 'played', 'studied', 'visited', 'decided',
            'provided', 'included', 'considered', 'developed', 'happened', 'changed',
            'starting', 'finishing', 'working', 'playing', 'studying', 'visiting',
            'deciding', 'providing', 'including', 'considering', 'developing', 'happening',
            
            // å…¶ä»–å¸¸è§è¯æ±‡
            'computer', 'internet', 'website', 'software', 'hardware', 'database',
            'network', 'system', 'program', 'project', 'product', 'service', 'business',
            'company', 'industry', 'technology', 'science', 'research', 'development',
            'management', 'marketing', 'advertising', 'customer', 'market', 'economy'
        ];

        // è·å–ç¿»è¯‘
        async function getTranslation(word) {
            // é¦–å…ˆæ£€æŸ¥æœ¬åœ°ç¿»è¯‘æ•°æ®åº“
            if (translationDatabase[word.toLowerCase()]) {
                return translationDatabase[word.toLowerCase()];
            }
            
            // å¦‚æœæœ¬åœ°æ²¡æœ‰ï¼Œå°è¯•ä½¿ç”¨å…è´¹ç¿»è¯‘API
            try {
                // æ–¹æ³•1ï¼šä½¿ç”¨æœ‰é“è¯å…¸APIï¼ˆå…è´¹ï¼‰
                const youdaoTranslation = await fetchYoudaoTranslation(word);
                if (youdaoTranslation) {
                    return youdaoTranslation;
                }
                
                // æ–¹æ³•2ï¼šä½¿ç”¨è¯å…¸APIè·å–é‡Šä¹‰ä½œä¸ºç¿»è¯‘
                const dictionaryTranslation = await fetchDictionaryTranslation(word);
                if (dictionaryTranslation) {
                    return dictionaryTranslation;
                }
                
                // æ–¹æ³•3ï¼šåŸºäºè¯æ ¹å’Œåç¼€çš„æ™ºèƒ½ç¿»è¯‘
                const smartTranslation = getSmartTranslation(word);
                if (smartTranslation) {
                    return smartTranslation;
                }
                
            } catch (error) {
                console.log('Translation API error:', error);
            }
            
            // å¦‚æœéƒ½å¤±è´¥äº†ï¼Œè¿”å›åŸºæœ¬ä¿¡æ¯
            return 'æš‚æ— ç¿»è¯‘';
        }

        // æœ‰é“è¯å…¸APIç¿»è¯‘ï¼ˆå…è´¹ç‰ˆæœ¬æœ‰é™åˆ¶ï¼‰
        async function fetchYoudaoTranslation(word) {
            try {
                // æ³¨æ„ï¼šè¿™ä¸ªAPIå¯èƒ½éœ€è¦æ³¨å†Œå’Œkeyï¼Œè¿™é‡Œæä¾›ç»“æ„
                // å®é™…ä½¿ç”¨æ—¶éœ€è¦æ›¿æ¢ä¸ºçœŸå®çš„API key
                const response = await fetch(`https://dict.youdao.com/jsonapi?q=${word}&le=en&t=1`);
                if (!response.ok) throw new Error('Youdao API failed');
                
                const data = await response.json();
                if (data && data.simple && data.simple.word && data.simple.word[0] && data.simple.word[0].usphone) {
                    return data.simple.word[0].trs.join('ï¼Œ');
                }
            } catch (error) {
                console.log('Youdao API error:', error);
                return null;
            }
        }

        // ä»è¯å…¸APIè·å–é‡Šä¹‰ä½œä¸ºç¿»è¯‘
        async function fetchDictionaryTranslation(word) {
            try {
                const response = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`);
                if (!response.ok) throw new Error('Dictionary API failed');
                
                const data = await response.json();
                if (data && data.length > 0) {
                    const definitions = [];
                    data[0].meanings?.forEach(meaning => {
                        meaning.definitions?.slice(0, 2).forEach(definition => {
                            if (definition.definition) {
                                definitions.push(definition.definition);
                            }
                        });
                    });
                    
                    if (definitions.length > 0) {
                        return definitions.join('ï¼›');
                    }
                }
            } catch (error) {
                console.log('Dictionary translation error:', error);
                return null;
            }
        }

        // æ™ºèƒ½ç¿»è¯‘ï¼ˆåŸºäºè¯æ ¹å’Œåç¼€ï¼‰
        function getSmartTranslation(word) {
            const word_lower = word.toLowerCase();
            
            // åŸºäºåç¼€çš„ç¿»è¯‘è§„åˆ™
            const suffixRules = {
                'tion': '...çš„åŠ¨ä½œ/çŠ¶æ€',
                'ation': '...åŒ–ï¼Œ...ä½œç”¨',
                'ization': '...åŒ–ï¼Œ...åŒ–è¿‡ç¨‹',
                'isation': '...åŒ–ï¼Œ...åŒ–è¿‡ç¨‹',
                'ive': '...çš„ï¼Œ...æ€§çš„',
                'ous': '...çš„ï¼Œå……æ»¡...çš„',
                'ful': 'å……æ»¡...çš„ï¼Œ...çš„',
                'less': 'æ²¡æœ‰...çš„ï¼Œæ— ...çš„',
                'ment': '...çŠ¶æ€ï¼Œ...ç»“æœ',
                'ness': '...æ€§è´¨ï¼Œ...çŠ¶æ€',
                'able': 'èƒ½...çš„ï¼Œå¯...çš„',
                'ible': 'èƒ½...çš„ï¼Œå¯...çš„',
                'ly': '...åœ°ï¼ˆå‰¯è¯ï¼‰',
                'ed': '...çš„ï¼ˆè¿‡å»å¼/è¿‡å»åˆ†è¯ï¼‰',
                'ing': '...çš„/æ­£åœ¨...ï¼ˆç°åœ¨åˆ†è¯ï¼‰',
                's': '...ï¼ˆå¤æ•°/ç¬¬ä¸‰äººç§°å•æ•°ï¼‰'
            };
            
            // æ£€æŸ¥å·²çŸ¥è¯æ ¹
            const knownRoots = {
                'organ': 'å™¨å®˜ï¼Œç»„ç»‡',
                'product': 'äº§å“ï¼Œç”Ÿäº§',
                'creat': 'åˆ›é€ ',
                'effect': 'æ•ˆæœï¼Œå½±å“',
                'protect': 'ä¿æŠ¤',
                'struct': 'å»ºé€ ï¼Œç»“æ„',
                'port': 'è¿è¾“ï¼Œæºå¸¦',
                'form': 'å½¢å¼ï¼Œå½¢æˆ',
                'act': 'è¡ŒåŠ¨ï¼Œä½œç”¨',
                'fact': 'äº‹å®ï¼Œåˆ¶é€ ',
                'duct': 'å¼•å¯¼ï¼Œä¼ å¯¼',
                'spect': 'çœ‹ï¼Œè§‚å¯Ÿ',
                'ject': 'æŠ•æ·ï¼Œå°„å‡º'
            };
            
            // å°è¯•åŒ¹é…è¯æ ¹å’Œåç¼€
            for (let suffix in suffixRules) {
                if (word_lower.endsWith(suffix)) {
                    const root = word_lower.slice(0, -suffix.length);
                    for (let knownRoot in knownRoots) {
                        if (root.includes(knownRoot)) {
                            return `ä¸"${knownRoots[knownRoot]}"ç›¸å…³çš„${suffixRules[suffix]}`;
                        }
                    }
                    return `${suffixRules[suffix]}`;
                }
            }
            
            return null;
        }

        // æ‰¹é‡è·å–ç¿»è¯‘
        async function getBatchTranslations(words) {
            const translations = {};
            
            // å¹¶å‘è·å–ç¿»è¯‘ï¼Œä½†é™åˆ¶å¹¶å‘æ•°é‡ä»¥é¿å…APIé™åˆ¶
            const batchSize = 5;
            for (let i = 0; i < words.length; i += batchSize) {
                const batch = words.slice(i, i + batchSize);
                const batchPromises = batch.map(async word => {
                    const translation = await getTranslation(word);
                    return { word, translation };
                });
                
                const batchResults = await Promise.all(batchPromises);
                batchResults.forEach(result => {
                    translations[result.word] = result.translation;
                });
                
                // æ·»åŠ å°å»¶è¿Ÿä»¥é¿å…APIé™åˆ¶
                if (i + batchSize < words.length) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
            }
            
            return translations;
        }

        // æœç´¢ç›¸ä¼¼å‘éŸ³çš„å•è¯ - é›†æˆç¿»è¯‘åŠŸèƒ½
        async function searchSimilarWords() {
            const searchInput = document.getElementById('searchInput');
            const word = searchInput.value.trim().toLowerCase();
            
            if (!word) {
                showError('è¯·è¾“å…¥ä¸€ä¸ªè‹±è¯­å•è¯');
                return;
            }

            // æ›´æ–°URL
            updateUrl(word);

            showLoading(true);
            hideError();

            try {
                // é¦–å…ˆæ£€æŸ¥æœ¬åœ°æ•°æ®åº“
                if (phoneticDatabase[word]) {
                    const data = phoneticDatabase[word];
                    // è·å–ç›¸ä¼¼è¯çš„ç¿»è¯‘
                    const translations = await getBatchTranslations([word, ...data.similar]);
                    displayResults(word, data, translations);
                } else {
                    // ä½¿ç”¨å¤šä¸ªå…è´¹APIæœç´¢
                    await searchFromMultipleAPIs(word);
                }
            } catch (error) {
                showError('æœç´¢è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯ï¼Œè¯·ç¨åé‡è¯•');
                console.error('Search error:', error);
            } finally {
                showLoading(false);
            }
        }

        // ä½¿ç”¨å¤šä¸ªAPIæœç´¢
        async function searchFromMultipleAPIs(word) {
            try {
                const [dictionaryData, rhymeWords, similarSoundWords, synonyms] = await Promise.allSettled([
                    fetchDictionaryData(word),
                    fetchRhymingWords(word),
                    fetchSimilarSoundingWords(word),
                    fetchSynonyms(word)
                ]);

                // æ”¶é›†æ‰€æœ‰ç›¸ä¼¼è¯
                const allSimilarWords = [];
                
                if (rhymeWords.status === 'fulfilled') {
                    allSimilarWords.push(...rhymeWords.value);
                }
                if (similarSoundWords.status === 'fulfilled') {
                    allSimilarWords.push(...similarSoundWords.value);
                }
                if (synonyms.status === 'fulfilled') {
                    allSimilarWords.push(...synonyms.value);
                }

                // å¦‚æœAPIè¿”å›çš„è¯ä¸å¤Ÿï¼Œè¡¥å……æœ¬åœ°ç®—æ³•ç”Ÿæˆçš„è¯
                if (allSimilarWords.length < 10) {
                    const localWords = generateSimilarWords(word);
                    allSimilarWords.push(...localWords);
                }

                // è·å–éŸ³æ ‡ä¿¡æ¯
                let phonetic = null;
                let syllables = null;
                
                if (dictionaryData.status === 'fulfilled' && dictionaryData.value) {
                    phonetic = dictionaryData.value.phonetic;
                    syllables = dictionaryData.value.syllables;
                }

                // åˆ›å»ºç»“æœæ•°æ®
                const phoneticData = {
                    modern: phonetic || generatePhonetic(word),
                    traditional: phonetic || generatePhonetic(word),
                    syllables: syllables || generateSyllables(word),
                    similar: [...new Set(allSimilarWords)].filter(w => w !== word).slice(0, 20)
                };

                // è·å–æ‰€æœ‰è¯çš„ç¿»è¯‘
                const allWords = [word, ...phoneticData.similar];
                const translations = await getBatchTranslations(allWords);

                displayResults(word, phoneticData, translations);

            } catch (error) {
                console.log('All APIs failed, using fallback:', error);
                // å®Œå…¨å›é€€åˆ°æœ¬åœ°ç®—æ³•
                await searchFromAPI(word);
            }
        }

        // æ¨¡æ‹ŸAPIæœç´¢ - ä½¿ç”¨çœŸå®çš„å…è´¹API
        async function searchFromAPI(word) {
            try {
                // ä½¿ç”¨Free Dictionary APIè·å–åŸºæœ¬ä¿¡æ¯
                const dictionaryData = await fetchDictionaryData(word);
                
                // ä½¿ç”¨WordsAPIè·å–ç›¸å…³è¯æ±‡
                const similarWords = await fetchSimilarWords(word);
                
                // ç”Ÿæˆè¯æ±‡æ•°æ®
                const phoneticData = {
                    modern: dictionaryData.phonetic || generatePhonetic(word),
                    traditional: dictionaryData.phonetic || generatePhonetic(word),
                    syllables: dictionaryData.syllables || generateSyllables(word),
                    similar: similarWords.length > 0 ? similarWords : generateSimilarWords(word)
                };

                // è·å–ç¿»è¯‘
                const allWords = [word, ...phoneticData.similar];
                const translations = await getBatchTranslations(allWords);

                displayResults(word, phoneticData, translations);
            } catch (error) {
                console.log('API search failed, using fallback algorithm:', error);
                // å¦‚æœAPIå¤±è´¥ï¼Œå›é€€åˆ°åŸæœ‰ç®—æ³•
                const similarWords = generateSimilarWords(word);
                const phoneticData = {
                    modern: generatePhonetic(word),
                    traditional: generatePhonetic(word),
                    syllables: generateSyllables(word),
                    similar: similarWords
                };
                
                // è·å–ç¿»è¯‘
                const allWords = [word, ...phoneticData.similar];
                const translations = await getBatchTranslations(allWords);
                
                displayResults(word, phoneticData, translations);
            }
        }

        // è·å–è¯å…¸æ•°æ®
        async function fetchDictionaryData(word) {
            try {
                const response = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`);
                if (!response.ok) throw new Error('Dictionary API failed');
                
                const data = await response.json();
                if (data && data.length > 0) {
                    const entry = data[0];
                    return {
                        phonetic: entry.phonetic || (entry.phonetics && entry.phonetics[0] && entry.phonetics[0].text) || null,
                        syllables: extractSyllables(entry.phonetic || entry.word)
                    };
                }
            } catch (error) {
                console.log('Dictionary API error:', error);
                return { phonetic: null, syllables: null };
            }
        }

        // è·å–ç›¸ä¼¼è¯æ±‡
        async function fetchSimilarWords(word) {
            const similarWords = [];
            
            try {
                // æ–¹æ³•1: ä½¿ç”¨WordsAPI (éœ€è¦API keyï¼Œè¿™é‡Œç”¨å¤‡ç”¨æ–¹æ¡ˆ)
                // const wordsApiData = await fetchWordsAPI(word);
                // similarWords.push(...wordsApiData);
                
                // æ–¹æ³•2: åŸºäºDatamuse APIè·å–ç›¸ä¼¼å‘éŸ³çš„è¯
                const rhymeData = await fetchRhymingWords(word);
                similarWords.push(...rhymeData);
                
                // æ–¹æ³•3: åŸºäºå­—å…¸APIçš„åŒä¹‰è¯
                const synonymData = await fetchSynonyms(word);
                similarWords.push(...synonymData);
                
            } catch (error) {
                console.log('Similar words API error:', error);
            }
            
            // å»é‡å¹¶é™åˆ¶æ•°é‡
            return [...new Set(similarWords)].slice(0, 20);
        }

        // è·å–æŠ¼éŸµè¯
        async function fetchRhymingWords(word) {
            try {
                const response = await fetch(`https://api.datamuse.com/words?rel_rhy=${word}&max=10`);
                if (!response.ok) throw new Error('Rhyme API failed');
                
                const data = await response.json();
                return data.map(item => item.word);
            } catch (error) {
                console.log('Rhyme API error:', error);
                return [];
            }
        }

        // è·å–å‘éŸ³ç›¸ä¼¼çš„è¯
        async function fetchSimilarSoundingWords(word) {
            try {
                const response = await fetch(`https://api.datamuse.com/words?sl=${word}&max=15`);
                if (!response.ok) throw new Error('Similar sound API failed');
                
                const data = await response.json();
                return data.map(item => item.word);
            } catch (error) {
                console.log('Similar sound API error:', error);
                return [];
            }
        }

        // è·å–åŒä¹‰è¯
        async function fetchSynonyms(word) {
            try {
                // ä½¿ç”¨å…è´¹çš„è¯å…¸APIè·å–åŒä¹‰è¯
                const response = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`);
                if (!response.ok) throw new Error('Synonym API failed');
                
                const data = await response.json();
                const synonyms = [];
                
                if (data && data.length > 0) {
                    data[0].meanings?.forEach(meaning => {
                        meaning.definitions?.forEach(definition => {
                            if (definition.synonyms) {
                                synonyms.push(...definition.synonyms);
                            }
                        });
                    });
                }
                
                return synonyms.slice(0, 10);
            } catch (error) {
                console.log('Synonym API error:', error);
                return [];
            }
        }

        // ä»éŸ³æ ‡æå–éŸ³èŠ‚
        function extractSyllables(phonetic) {
            if (!phonetic) return null;
            
            // ç®€å•çš„éŸ³èŠ‚åˆ†å‰²ï¼ˆåŸºäºé‡éŸ³ç¬¦å·ï¼‰
            const syllables = phonetic.split(/[ËˆËŒ]/).filter(s => s.length > 0);
            return syllables.length > 0 ? syllables : null;
        }

        // ç”ŸæˆéŸ³æ ‡ï¼ˆç®€åŒ–é€»è¾‘ï¼‰
        function generatePhonetic(word) {
            const vowelMap = {
                'a': 'Ã¦', 'e': 'É›', 'i': 'Éª', 'o': 'É’', 'u': 'ÊŒ'
            };
            
            let phonetic = '';
            for (let char of word) {
                if (vowelMap[char]) {
                    phonetic += vowelMap[char];
                } else {
                    phonetic += char;
                }
            }
            return phonetic;
        }

        // ç”ŸæˆéŸ³èŠ‚
        function generateSyllables(word) {
            const syllables = [];
            let currentSyllable = '';
            
            for (let i = 0; i < word.length; i++) {
                currentSyllable += word[i];
                if (isVowel(word[i]) && i < word.length - 1 && !isVowel(word[i + 1])) {
                    syllables.push(currentSyllable.toUpperCase());
                    currentSyllable = '';
                }
            }
            
            if (currentSyllable) {
                syllables.push(currentSyllable.toLowerCase());
            }
            
            return syllables.length > 0 ? syllables : [word.toUpperCase()];
        }

        function isVowel(char) {
            return 'aeiou'.includes(char.toLowerCase());
        }

        // ç”Ÿæˆç›¸ä¼¼å•è¯ - æ”¹è¿›çš„ç®—æ³•
        function generateSimilarWords(word) {
            const similar = [];
            
            // 1. ç›´æ¥å˜å½¢ï¼ˆå¤æ•°ã€è¿‡å»å¼ç­‰ï¼‰
            const directVariations = generateDirectVariations(word);
            similar.push(...directVariations);
            
            // 2. åŸºäºéŸ³éŸµæ¨¡å¼åŒ¹é…
            const phoneticMatches = findPhoneticMatches(word);
            similar.push(...phoneticMatches);
            
            // 3. è¯æ ¹ç›¸åŒçš„è¯
            const rootMatches = findRootMatches(word);
            similar.push(...rootMatches);
            
            // 4. éŸ³èŠ‚ç»“æ„ç›¸ä¼¼çš„è¯
            const syllableMatches = findSyllableMatches(word);
            similar.push(...syllableMatches);
            
            // å»é‡å¹¶é™åˆ¶æ•°é‡
            const uniqueSimilar = [...new Set(similar)].filter(w => w !== word);
            
            // æŒ‰ç›¸ä¼¼åº¦æ’åº
            return uniqueSimilar
                .map(w => ({ word: w, similarity: calculatePhoneticSimilarity(word, w) }))
                .sort((a, b) => b.similarity - a.similarity)
                .slice(0, 20)
                .map(item => item.word);
        }
        
        // ç”Ÿæˆç›´æ¥å˜å½¢
        function generateDirectVariations(word) {
            const variations = [];
            
            // è‹±ç¾æ‹¼å†™å·®å¼‚
            if (word.includes('ization')) {
                variations.push(word.replace('ization', 'isation'));
            }
            if (word.includes('isation')) {
                variations.push(word.replace('isation', 'ization'));
            }
            
            // å¤æ•°å½¢å¼
            if (word.endsWith('tion')) {
                variations.push(word + 's');
            }
            if (word.endsWith('ion')) {
                variations.push(word + 's');
            }
            
            // å½¢å®¹è¯å½¢å¼
            if (word.endsWith('tion')) {
                const base = word.slice(0, -4);
                variations.push(base + 'tional');
            }
            if (word.endsWith('ization')) {
                const base = word.slice(0, -8);
                variations.push(base + 'ize');
                variations.push(base + 'izing');
                variations.push(base + 'ized');
            }
            
            // è¯æ ¹å˜åŒ–
            if (word.startsWith('re')) {
                variations.push(word.slice(2)); // å»æ‰ re- å‰ç¼€
                variations.push('dis' + word.slice(2)); // dis- å‰ç¼€
                variations.push('un' + word.slice(2)); // un- å‰ç¼€
            }
            
            return variations.filter(v => v.length > 2);
        }
        
        // åŸºäºéŸ³éŸµæ¨¡å¼åŒ¹é…
        function findPhoneticMatches(word) {
            const matches = [];
            
            // ç›¸åŒç»“å°¾çš„è¯
            const endings = ['-ation', '-tion', '-sion', '-ization', '-isation', '-ism', '-ist', '-ity', '-ive', '-ous'];
            
            endings.forEach(ending => {
                const suffix = ending.slice(1); // å»æ‰ -
                if (word.endsWith(suffix)) {
                    const stem = word.slice(0, -suffix.length);
                    
                    // æŸ¥æ‰¾å…¶ä»–ä»¥ç›¸åŒè¯æ ¹å¼€å¤´çš„è¯
                    extendedVocabulary.forEach(vocabWord => {
                        if (vocabWord.startsWith(stem) && vocabWord !== word) {
                            matches.push(vocabWord);
                        }
                    });
                    
                    // æŸ¥æ‰¾å…¶ä»–ç›¸åŒç»“å°¾çš„è¯
                    extendedVocabulary.forEach(vocabWord => {
                        if (vocabWord.endsWith(suffix) && 
                            vocabWord !== word && 
                            Math.abs(vocabWord.length - word.length) <= 4) {
                            matches.push(vocabWord);
                        }
                    });
                }
            });
            
            return matches;
        }
        
        // æŸ¥æ‰¾è¯æ ¹åŒ¹é…
        function findRootMatches(word) {
            const matches = [];
            
            // æå–å¯èƒ½çš„è¯æ ¹
            let root = word;
            const prefixes = ['re', 'un', 'dis', 'pre', 'over', 'under', 'out', 'mis'];
            const suffixes = ['tion', 'sion', 'ation', 'ization', 'isation', 'ity', 'ive', 'ous', 'al', 'ic', 'ed', 'ing', 's'];
            
            // å»æ‰å‰ç¼€
            prefixes.forEach(prefix => {
                if (root.startsWith(prefix)) {
                    root = root.slice(prefix.length);
                }
            });
            
            // å»æ‰åç¼€
            suffixes.forEach(suffix => {
                if (root.endsWith(suffix)) {
                    root = root.slice(0, -suffix.length);
                }
            });
            
            // æŸ¥æ‰¾åŒ…å«ç›¸åŒè¯æ ¹çš„è¯
            if (root.length >= 3) {
                extendedVocabulary.forEach(vocabWord => {
                    if (vocabWord.includes(root) && vocabWord !== word) {
                        matches.push(vocabWord);
                    }
                });
            }
            
            return matches;
        }
        
        // æŸ¥æ‰¾éŸ³èŠ‚ç»“æ„ç›¸ä¼¼çš„è¯
        function findSyllableMatches(word) {
            const matches = [];
            const wordSyllables = generateSyllables(word);
            const wordSyllableCount = wordSyllables.length;
            
            extendedVocabulary.forEach(vocabWord => {
                if (vocabWord === word) return;
                
                const vocabSyllables = generateSyllables(vocabWord);
                const vocabSyllableCount = vocabSyllables.length;
                
                // éŸ³èŠ‚æ•°é‡ç›¸è¿‘
                if (Math.abs(wordSyllableCount - vocabSyllableCount) <= 1) {
                    // æ£€æŸ¥éŸ³èŠ‚ç»“æ„ç›¸ä¼¼åº¦
                    const syllableSimilarity = calculateSyllableSimilarity(wordSyllables, vocabSyllables);
                    if (syllableSimilarity > 0.3) {
                        matches.push(vocabWord);
                    }
                }
            });
            
            return matches;
        }
        
        // è®¡ç®—éŸ³èŠ‚ç›¸ä¼¼åº¦
        function calculateSyllableSimilarity(syllables1, syllables2) {
            let matchCount = 0;
            const maxLength = Math.max(syllables1.length, syllables2.length);
            
            for (let i = 0; i < Math.min(syllables1.length, syllables2.length); i++) {
                if (syllables1[i].toLowerCase() === syllables2[i].toLowerCase()) {
                    matchCount++;
                } else if (syllables1[i].toLowerCase().includes(syllables2[i].toLowerCase()) ||
                          syllables2[i].toLowerCase().includes(syllables1[i].toLowerCase())) {
                    matchCount += 0.5;
                }
            }
            
            return matchCount / maxLength;
        }
        
        // è®¡ç®—è¯­éŸ³ç›¸ä¼¼åº¦
        function calculatePhoneticSimilarity(word1, word2) {
            // åŸºäºå¤šä¸ªå› ç´ è®¡ç®—ç›¸ä¼¼åº¦
            let similarity = 0;
            
            // 1. è¯é•¿ç›¸ä¼¼åº¦
            const lengthSimilarity = 1 - Math.abs(word1.length - word2.length) / Math.max(word1.length, word2.length);
            similarity += lengthSimilarity * 0.2;
            
            // 2. å¼€å¤´ç›¸ä¼¼åº¦
            const prefixLength = Math.min(3, Math.min(word1.length, word2.length));
            let prefixMatch = 0;
            for (let i = 0; i < prefixLength; i++) {
                if (word1[i].toLowerCase() === word2[i].toLowerCase()) {
                    prefixMatch++;
                }
            }
            similarity += (prefixMatch / prefixLength) * 0.3;
            
            // 3. ç»“å°¾ç›¸ä¼¼åº¦
            const suffixLength = Math.min(4, Math.min(word1.length, word2.length));
            let suffixMatch = 0;
            for (let i = 0; i < suffixLength; i++) {
                const pos1 = word1.length - 1 - i;
                const pos2 = word2.length - 1 - i;
                if (word1[pos1].toLowerCase() === word2[pos2].toLowerCase()) {
                    suffixMatch++;
                }
            }
            similarity += (suffixMatch / suffixLength) * 0.3;
            
            // 4. ç¼–è¾‘è·ç¦»ç›¸ä¼¼åº¦
            const editSimilarity = 1 - editDistance(word1, word2) / Math.max(word1.length, word2.length);
            similarity += editSimilarity * 0.2;
            
            return similarity;
        }

        // è®¡ç®—å•è¯ç›¸ä¼¼åº¦ - ä¿ç•™åŸæœ‰å‡½æ•°åä½†æ”¹è¿›ç®—æ³•
        function calculateSimilarity(word1, word2) {
            return calculatePhoneticSimilarity(word1, word2);
        }

        // è®¡ç®—ç¼–è¾‘è·ç¦»
        function editDistance(str1, str2) {
            const matrix = Array(str2.length + 1).fill().map(() => Array(str1.length + 1).fill(0));
            
            for (let i = 0; i <= str1.length; i++) matrix[0][i] = i;
            for (let j = 0; j <= str2.length; j++) matrix[j][0] = j;
            
            for (let j = 1; j <= str2.length; j++) {
                for (let i = 1; i <= str1.length; i++) {
                    if (str1[i - 1] === str2[j - 1]) {
                        matrix[j][i] = matrix[j - 1][i - 1];
                    } else {
                        matrix[j][i] = Math.min(
                            matrix[j - 1][i - 1] + 1,
                            matrix[j][i - 1] + 1,
                            matrix[j - 1][i] + 1
                        );
                    }
                }
            }
            
            return matrix[str2.length][str1.length];
        }

        // æ˜¾ç¤ºæœç´¢ç»“æœ - æ›´æ–°ç‰ˆæœ¬åŒ…å«ç¿»è¯‘
        function displayResults(word, data, translations) {
            // æ˜¾ç¤ºéŸ³æ ‡ä¿¡æ¯
            const phoneticInfo = document.getElementById('phoneticInfo');
            const phoneticTranscription = document.getElementById('phoneticTranscription');
            const wordTranslation = document.getElementById('wordTranslation');
            
            phoneticTranscription.innerHTML = `
                <li><span class="bold">Modern IPA:</span> ${data.modern}</li>
                <li><span class="bold">Traditional IPA:</span> ${data.traditional}</li>
                <li><span class="bold">${data.syllables.length} syllables:</span>
                    <div class="syllables">
                        ${data.syllables.map(syllable => `"${syllable}"`).join(' + ')}
                    </div>
                </li>
            `;
            
            // æ˜¾ç¤ºæŸ¥è¯¢è¯çš„ç¿»è¯‘
            const queryTranslation = translations[word] || 'æš‚æ— ç¿»è¯‘';
            wordTranslation.innerHTML = `
                <div class="word-text">${word}</div>
                <div class="translation-text">${queryTranslation}</div>
            `;
            
            phoneticInfo.style.display = 'block';

            // æ˜¾ç¤ºç›¸ä¼¼å•è¯åŠå…¶ç¿»è¯‘
            const similarWords = document.getElementById('similarWords');
            const wordGrid = document.getElementById('wordGrid');
            
            wordGrid.innerHTML = data.similar.map(similarWord => {
                const translation = translations[similarWord] || 'æš‚æ— ç¿»è¯‘';
                return `<div class="word-item" onclick="searchExample('${similarWord}')">
                    <div class="word-english">${similarWord}</div>
                    <div class="word-chinese">${translation}</div>
                </div>`;
            }).join('');
            
            similarWords.style.display = 'block';
        }

        // æ˜¾ç¤º/éšè—åŠ è½½çŠ¶æ€
        function showLoading(show) {
            document.getElementById('loading').style.display = show ? 'block' : 'none';
            document.getElementById('searchInput').disabled = show;
            document.querySelector('.search-btn').disabled = show;
        }

        // æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
        function showError(message) {
            const errorElement = document.getElementById('errorMessage');
            errorElement.textContent = message;
            errorElement.style.display = 'block';
        }

        // éšè—é”™è¯¯ä¿¡æ¯
        function hideError() {
            document.getElementById('errorMessage').style.display = 'none';
        }

        // ç¤ºä¾‹æœç´¢
        function searchExample(word) {
            document.getElementById('searchInput').value = word;
            updateUrl(word); // åŒæ—¶æ›´æ–°URL
            searchSimilarWords();
        }

        // å›è½¦æœç´¢
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchSimilarWords();
            }
        });

        // URLå‚æ•°å¤„ç†
        function getUrlParameter(name) {
            name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
            const regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
            const results = regex.exec(location.search);
            return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
        }

        // æ›´æ–°URL
        function updateUrl(word) {
            const newUrl = window.location.origin + window.location.pathname + '?w=' + encodeURIComponent(word);
            window.history.pushState({word: word}, '', newUrl);
        }

        // ä»URLå‚æ•°è‡ªåŠ¨æœç´¢
        function searchFromUrl() {
            const wordFromUrl = getUrlParameter('w');
            if (wordFromUrl) {
                document.getElementById('searchInput').value = wordFromUrl;
                searchSimilarWords();
            }
        }

        // é¡µé¢åŠ è½½å®Œæˆåçš„åˆå§‹åŒ–
        window.addEventListener('load', function() {
            // å…ˆæ£€æŸ¥URLå‚æ•°
            searchFromUrl();
            // èšç„¦è¾“å…¥æ¡†
            document.getElementById('searchInput').focus();
        });

        // å¤„ç†æµè§ˆå™¨å‰è¿›åé€€
        window.addEventListener('popstate', function(event) {
            if (event.state && event.state.word) {
                document.getElementById('searchInput').value = event.state.word;
                searchSimilarWords();
            } else {
                // æ¸…ç©ºæœç´¢ç»“æœ
                document.getElementById('phoneticInfo').style.display = 'none';
                document.getElementById('similarWords').style.display = 'none';
                document.getElementById('searchInput').value = '';
            }
        });
    </script>
</body>
</html>
